# Models Module

## Purpose

The Models Module provides shared data models, interfaces, and type definitions used across all components of the test case generator. It ensures type safety and consistency throughout the system.

## Features

- Common data structures for all modules
- Type definitions for TypeScript
- Validation schemas
- Serialization/deserialization utilities
- Domain model documentation

## Core Models

### Code Models

```typescript
/**
 * Represents parsed source code with metadata
 */
interface ParsedCode {
  language: string;
  filePath: string;
  ast: ASTNode;
  functions: FunctionMetadata[];
  classes: ClassMetadata[];
  imports: ImportStatement[];
  exports: ExportStatement[];
  metadata: CodeMetadata;
}

/**
 * Metadata for a function
 */
interface FunctionMetadata {
  name: string;
  parameters: Parameter[];
  returnType: Type;
  isAsync: boolean;
  isPublic: boolean;
  complexity: number;
  documentation?: string;
  location: SourceLocation;
}

/**
 * Metadata for a class
 */
interface ClassMetadata {
  name: string;
  methods: FunctionMetadata[];
  properties: PropertyMetadata[];
  isExported: boolean;
  superClass?: string;
  interfaces?: string[];
  documentation?: string;
}

/**
 * Function or method parameter
 */
interface Parameter {
  name: string;
  type: Type;
  optional: boolean;
  defaultValue?: any;
}
```

### Test Models

```typescript
/**
 * Test scenario generated by analyzer
 */
interface TestScenario {
  id: string;
  type: 'unit' | 'integration' | 'edge-case' | 'contract';
  targetFunction: string;
  targetModule: string;
  description: string;
  priority: 'high' | 'medium' | 'low';
  inputs: TestInput[];
  expectedOutput: any;
  preconditions?: string[];
  postconditions?: string[];
  tags: string[];
}

/**
 * Generated test case
 */
interface GeneratedTest {
  id: string;
  scenarioId: string;
  name: string;
  description: string;
  code: string;
  framework: string;
  language: string;
  imports: string[];
  fixtures: Fixture[];
  mocks: MockDefinition[];
  metadata: TestMetadata;
}

/**
 * Test input data
 */
interface TestInput {
  name: string;
  value: any;
  type: Type;
  description?: string;
}

/**
 * Test fixture data
 */
interface Fixture {
  name: string;
  data: any;
  setup?: string;
  teardown?: string;
}
```

### Specification Models

```typescript
/**
 * Feature specification
 */
interface Specification {
  featureName: string;
  featureId: string;
  userStories: UserStory[];
  requirements: Requirement[];
  entities: Entity[];
  successCriteria: SuccessCriterion[];
}

/**
 * User story from specification
 */
interface UserStory {
  id: string;
  title: string;
  priority: 'P1' | 'P2' | 'P3' | 'P4';
  description: string;
  acceptanceCriteria: AcceptanceCriterion[];
  independentTest: string;
}

/**
 * Functional requirement
 */
interface Requirement {
  id: string;
  category: 'functional' | 'non-functional';
  description: string;
  priority: 'must' | 'should' | 'could';
  testable: boolean;
}
```

### Validation Models

```typescript
/**
 * Validation result
 */
interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  suggestions: string[];
  timestamp: Date;
}

/**
 * Validation error
 */
interface ValidationError {
  line: number;
  column: number;
  message: string;
  severity: 'error' | 'warning' | 'info';
  code: string;
  source: string;
  fixSuggestion?: FixSuggestion;
}

/**
 * Completeness report
 */
interface CompletenessReport {
  complete: boolean;
  totalScenarios: number;
  implementedScenarios: number;
  missingScenarios: TestScenario[];
  coverageGaps: CoverageGap[];
}
```

### Common Types

```typescript
/**
 * Source code location
 */
interface SourceLocation {
  filePath: string;
  startLine: number;
  endLine: number;
  startColumn: number;
  endColumn: number;
}

/**
 * Type information
 */
interface Type {
  name: string;
  primitive: boolean;
  nullable: boolean;
  array: boolean;
  generic?: Type[];
}

/**
 * Code metadata
 */
interface CodeMetadata {
  version: string;
  author?: string;
  lastModified: Date;
  linesOfCode: number;
  complexity: number;
}
```

## Usage Examples

### Example 1: Creating a Test Scenario

```typescript
import { TestScenario, TestInput } from './models';

const scenario: TestScenario = {
  id: 'TS001',
  type: 'unit',
  targetFunction: 'calculateSum',
  targetModule: 'math',
  description: 'Should add two positive numbers',
  priority: 'high',
  inputs: [
    { name: 'a', value: 5, type: { name: 'number', primitive: true, nullable: false, array: false } },
    { name: 'b', value: 3, type: { name: 'number', primitive: true, nullable: false, array: false } }
  ],
  expectedOutput: 8,
  tags: ['arithmetic', 'basic']
};
```

### Example 2: Working with Function Metadata

```typescript
import { FunctionMetadata, Parameter } from './models';

const functionMeta: FunctionMetadata = {
  name: 'processUser',
  parameters: [
    {
      name: 'userId',
      type: { name: 'string', primitive: true, nullable: false, array: false },
      optional: false
    },
    {
      name: 'options',
      type: { name: 'ProcessOptions', primitive: false, nullable: false, array: false },
      optional: true,
      defaultValue: {}
    }
  ],
  returnType: { name: 'Promise', primitive: false, nullable: false, array: false, generic: [
    { name: 'User', primitive: false, nullable: false, array: false }
  ]},
  isAsync: true,
  isPublic: true,
  complexity: 5,
  location: {
    filePath: './src/users/service.ts',
    startLine: 42,
    endLine: 67,
    startColumn: 0,
    endColumn: 1
  }
};
```

### Example 3: Validation Result

```typescript
import { ValidationResult, ValidationError } from './models';

const result: ValidationResult = {
  valid: false,
  errors: [
    {
      line: 15,
      column: 20,
      message: 'Expected assertion after function call',
      severity: 'error',
      code: 'MISSING_ASSERTION',
      source: 'validator',
      fixSuggestion: {
        description: 'Add expect() assertion',
        fixedCode: 'expect(result).toBe(expected);',
        autoFixable: true
      }
    }
  ],
  warnings: [],
  suggestions: ['Consider adding edge case tests'],
  timestamp: new Date()
};
```

## Type Guards

The module provides type guard functions for runtime type checking:

```typescript
/**
 * Check if object is a valid TestScenario
 */
export function isTestScenario(obj: any): obj is TestScenario {
  return (
    typeof obj === 'object' &&
    typeof obj.id === 'string' &&
    typeof obj.type === 'string' &&
    ['unit', 'integration', 'edge-case', 'contract'].includes(obj.type)
  );
}

/**
 * Check if object is a valid ValidationError
 */
export function isValidationError(obj: any): obj is ValidationError {
  return (
    typeof obj === 'object' &&
    typeof obj.line === 'number' &&
    typeof obj.message === 'string'
  );
}
```

## Validation Schemas

For runtime validation (using Zod or similar):

```typescript
import { z } from 'zod';

export const TestScenarioSchema = z.object({
  id: z.string(),
  type: z.enum(['unit', 'integration', 'edge-case', 'contract']),
  targetFunction: z.string(),
  targetModule: z.string(),
  description: z.string(),
  priority: z.enum(['high', 'medium', 'low']),
  inputs: z.array(TestInputSchema),
  expectedOutput: z.any(),
  tags: z.array(z.string())
});
```

## Serialization

Helper functions for serialization:

```typescript
/**
 * Serialize model to JSON
 */
export function serialize<T>(model: T): string {
  return JSON.stringify(model, null, 2);
}

/**
 * Deserialize JSON to model
 */
export function deserialize<T>(json: string, validator?: (obj: any) => obj is T): T {
  const obj = JSON.parse(json);
  if (validator && !validator(obj)) {
    throw new Error('Invalid model format');
  }
  return obj as T;
}
```

## Dependencies

- **Zod** (optional): Runtime validation schemas
- **TypeScript**: Type definitions

## Testing

### Unit Tests

```bash
npm test src/models/tests/unit
```

Test coverage:

- Type guard functions
- Serialization/deserialization
- Schema validation
- Model creation utilities

## Documentation

Each model interface includes:

- JSDoc comments explaining purpose
- Property descriptions
- Usage examples
- Related interfaces

## Contributing

When adding new models:

1. Define interface with complete JSDoc
2. Add type guard function
3. Add validation schema (if needed)
4. Add usage examples to this README
5. Add unit tests for type guards
6. Update dependent modules

## Best Practices

- Use readonly properties where appropriate
- Prefer interfaces over types for extensibility
- Always provide JSDoc comments
- Use discriminated unions for polymorphic types
- Keep models simple and focused

## Future Enhancements

- [ ] GraphQL schema generation
- [ ] OpenAPI spec generation
- [ ] Model versioning support
- [ ] Migration utilities
- [ ] Model validation decorators

---

**Module Status**: Planning Phase
**Last Updated**: 2025-10-25
